<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>ИНФЕРНО - Бесконечное Выживание</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        body {
            background: #000;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        
        #rotate-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a0000 0%, #000 50%, #0a0a1a 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
        }
        
        #rotate-screen .phone-icon {
            width: 80px;
            height: 140px;
            border: 4px solid #ff6600;
            border-radius: 10px;
            position: relative;
            animation: rotatePhone 2s ease-in-out infinite;
            margin-bottom: 30px;
        }
        
        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        #rotate-screen h2 {
            color: #ff6600;
            font-size: 24px;
            text-align: center;
            text-shadow: 0 0 20px rgba(255,102,0,0.5);
        }
        
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        
        #hud {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(to bottom, #1a1a1a, #0d0d0d);
            border-top: 3px solid #333;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 100;
        }
        
        .hud-item { text-align: center; color: #fff; text-shadow: 2px 2px 0 #000; }
        .hud-label { font-size: 10px; color: #888; }
        .hud-value { font-size: 24px; font-weight: bold; }
        #health .hud-value { color: #ff4444; }
        #armor .hud-value { color: #4444ff; }
        #kills .hud-value { color: #ff6600; }
        #weapon .hud-value { color: #44ff44; font-size: 14px; }
        
        #joystick-container {
            position: fixed;
            left: 20px;
            bottom: 100px;
            width: 120px;
            height: 120px;
            z-index: 101;
        }
        
        #joystick-base {
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.15);
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            position: relative;
        }
        
        #joystick-stick {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #ff6600, #cc3300);
            border: 2px solid #ff9933;
            border-radius: 50%;
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        #look-area {
            position: fixed;
            right: 0;
            top: 0;
            width: 50%;
            height: calc(100% - 60px);
            z-index: 99;
        }
        
        .action-btn {
            position: fixed;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: 3px solid;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            line-height: 64px;
            z-index: 101;
            color: #fff;
        }
        
        #fire-btn {
            right: 20px;
            bottom: 120px;
            background: radial-gradient(circle, #ff3333, #990000);
            border-color: #ff6666;
            width: 90px;
            height: 90px;
            line-height: 84px;
            font-size: 14px;
        }
        
        #weapon-btn {
            right: 130px;
            bottom: 100px;
            background: radial-gradient(circle, #3366ff, #003399);
            border-color: #6699ff;
        }
        
        #menu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to bottom, #1a0000, #000);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #menu h1 {
            font-size: 48px;
            color: #ff3300;
            text-shadow: 4px 4px 0 #660000, 0 0 30px #ff0000;
            margin-bottom: 20px;
            animation: titlePulse 2s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { text-shadow: 4px 4px 0 #660000, 0 0 30px #ff0000; }
            50% { text-shadow: 4px 4px 0 #660000, 0 0 60px #ff0000; }
        }
        
        #menu h2 { font-size: 16px; color: #888; margin-bottom: 10px; }
        #menu h3 { font-size: 14px; color: #ff6600; margin-bottom: 30px; }
        
        .menu-btn {
            width: 280px;
            padding: 15px;
            margin: 10px;
            font-size: 20px;
            font-family: 'Courier New', monospace;
            background: linear-gradient(to bottom, #333, #111);
            border: 3px solid #666;
            color: #ff6600;
            cursor: pointer;
        }
        
        .menu-btn:active { background: linear-gradient(to bottom, #ff6600, #cc3300); color: #fff; }
        
        #message {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: #ffff00;
            padding: 10px 20px;
            font-size: 18px;
            border: 2px solid #ffff00;
            z-index: 150;
            display: none;
        }
        
        #damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.4));
            pointer-events: none;
            z-index: 98;
            opacity: 0;
            transition: opacity 0.1s;
        }
        
        #heal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 30%, rgba(0,255,0,0.3));
            pointer-events: none;
            z-index: 98;
            opacity: 0;
            transition: opacity 0.2s;
        }
        
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            pointer-events: none;
        }
        
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: #fff;
        }
        
        #crosshair::before { width: 20px; height: 2px; left: -10px; top: -1px; }
        #crosshair::after { width: 2px; height: 20px; left: -1px; top: -10px; }
        
        #level-info {
            position: fixed;
            top: 10px;
            left: 10px;
            color: #888;
            font-size: 14px;
            z-index: 100;
        }
        
        #minimap {
            position: fixed;
            top: 40px;
            left: 10px;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.7);
            border: 2px solid #333;
            z-index: 100;
        }
        
        #fullscreen-btn {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #666;
            border-radius: 5px;
            z-index: 101;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 20px;
        }
        
        #gameover {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(100,0,0,0.9);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }
        
        #gameover h1 { font-size: 48px; color: #ff0000; margin-bottom: 30px; }
        #gameover h2 { font-size: 24px; color: #ff6600; margin-bottom: 20px; }
        
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div id="rotate-screen">
        <div class="phone-icon"></div>
        <h2>ПОВЕРНИТЕ УСТРОЙСТВО</h2>
    </div>
    
    <div id="menu">
        <h1>ИНФЕРНО</h1>
        <h2>Мобильный FPS Шутер</h2>
        <h3>∞ БЕСКОНЕЧНОЕ ВЫЖИВАНИЕ ∞</h3>
        <button class="menu-btn" id="start-btn">НАЧАТЬ ИГРУ</button>
        <button class="menu-btn" id="fullscreen-menu-btn">ПОЛНЫЙ ЭКРАН</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <div id="hud" class="hidden">
        <div class="hud-item" id="health">
            <div class="hud-label">ЗДОРОВЬЕ</div>
            <div class="hud-value">100</div>
        </div>
        <div class="hud-item" id="armor">
            <div class="hud-label">БРОНЯ</div>
            <div class="hud-value">0</div>
        </div>
        <div class="hud-item" id="kills">
            <div class="hud-label">УБИЙСТВА</div>
            <div class="hud-value">0</div>
        </div>
        <div class="hud-item" id="weapon">
            <div class="hud-label">ОРУЖИЕ</div>
            <div class="hud-value">НОЖ</div>
        </div>
    </div>
    
    <div id="joystick-container" class="hidden">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>
    
    <div id="look-area" class="hidden"></div>
    <div id="fire-btn" class="action-btn hidden">АТАКА</div>
    <div id="weapon-btn" class="action-btn hidden">ОРУЖИЕ</div>
    <div id="fullscreen-btn" class="hidden">⛶</div>
    <div id="crosshair" class="hidden"></div>
    <div id="level-info" class="hidden">БЕСКОНЕЧНОЕ ВЫЖИВАНИЕ</div>
    <canvas id="minimap" class="hidden"></canvas>
    <div id="message"></div>
    <div id="damage-overlay"></div>
    <div id="heal-overlay"></div>
    
    <div id="gameover">
        <h1>ВЫ ПОГИБЛИ</h1>
        <h2>УБИЙСТВ: <span id="final-kills">0</span></h2>
        <button class="menu-btn" id="restart-btn">ЗАНОВО</button>
        <button class="menu-btn" id="menu-btn">ГЛАВНОЕ МЕНЮ</button>
    </div>

    <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    
    let gameRunning = false;
    let lastTime = 0;
    
    // Настройки спавна
    const SPAWN_INTERVAL = 4000; // Каждые 4 секунды
    const MAX_ENEMIES = 8; // Максимум 8 врагов
    let lastSpawnTime = 0;
    
    // Игрок
    const player = {
        x: 12, y: 12,
        angle: 0, pitch: 0,
        health: 100, maxHealth: 200,
        armor: 0, maxArmor: 100,
        weapons: [
            { name: 'НОЖ', damage: 999, fireRate: 400, range: 1.8, isKnife: true },
            { name: 'ПЛАЗМА', damage: 45, fireRate: 150, spread: 0.02, auto: true, projectileSpeed: 15 }
        ],
        currentWeapon: 0,
        kills: 0,
        lastFireTime: 0,
        bobPhase: 0
    };
    
    // Карта - открытая арена
    const levelMap = [
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
        [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,5,5,5,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,3,3,0,0,0,0,0,0,0,3,3,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
        [1,0,0,2,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
        [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];
    
    // Точки спавна - в поле зрения игрока
    const spawnPoints = [
        {x:12,y:5}, {x:12,y:17}, {x:5,y:10}, {x:19,y:10},
        {x:8,y:5}, {x:16,y:5}, {x:8,y:17}, {x:16,y:17}
    ];
    
    let enemies = [];
    let items = [];
    let projectiles = [];
    let particles = [];
    
    const ENEMY_TYPES = {
        imp: { health: 40, speed: 2.5, damage: 10, attackRange: 8, color: '#884422', size: 0.4, ranged: true, projectileSpeed: 6, attackCooldown: 2000 },
        demon: { health: 100, speed: 4, damage: 25, attackRange: 1.5, color: '#aa3366', size: 0.5, ranged: false, attackCooldown: 1000 },
        soldier: { health: 60, speed: 2, damage: 12, attackRange: 12, color: '#556633', size: 0.4, ranged: true, projectileSpeed: 10, attackCooldown: 1500 },
        baron: { health: 250, speed: 2, damage: 40, attackRange: 10, color: '#663333', size: 0.7, ranged: true, projectileSpeed: 8, attackCooldown: 2500 }
    };
    
    // Проверка ориентации
    function checkOrientation() {
        const isPortrait = window.innerHeight > window.innerWidth;
        const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        document.getElementById('rotate-screen').style.display = (isMobile && isPortrait) ? 'flex' : 'none';
    }
    
    function toggleFullscreen() {
        if (!document.fullscreenElement) {
            document.documentElement.requestFullscreen?.() || document.documentElement.webkitRequestFullscreen?.();
        } else {
            document.exitFullscreen?.() || document.webkitExitFullscreen?.();
        }
    }
    
    window.addEventListener('resize', checkOrientation);
    window.addEventListener('orientationchange', () => setTimeout(checkOrientation, 100));
    
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        minimapCanvas.width = 100;
        minimapCanvas.height = 100;
    }
    
    // Текстуры
    const textureCache = {};
    function generateTexture(type, size = 64) {
        if (textureCache[type]) return textureCache[type];
        const c = document.createElement('canvas');
        c.width = c.height = size;
        const tx = c.getContext('2d');
        
        if (type === 1) {
            tx.fillStyle = '#555';
            tx.fillRect(0, 0, size, size);
            for (let y = 0; y < size; y += 16) {
                for (let x = 0; x < size; x += 32) {
                    const off = (Math.floor(y/16)%2)*16;
                    tx.fillStyle = `rgb(${70+Math.random()*30},${70+Math.random()*30},${70+Math.random()*30})`;
                    tx.fillRect(x+off, y, 30, 14);
                }
            }
        } else if (type === 2) {
            tx.fillStyle = '#661111';
            tx.fillRect(0, 0, size, size);
            for (let i = 0; i < 50; i++) {
                tx.fillStyle = `rgba(${150+Math.random()*50},20,20,0.5)`;
                tx.beginPath();
                tx.arc(Math.random()*size, Math.random()*size, Math.random()*10+5, 0, Math.PI*2);
                tx.fill();
            }
        } else if (type === 3) {
            tx.fillStyle = '#112244';
            tx.fillRect(0, 0, size, size);
            for (let y = 0; y < size; y += 32) {
                for (let x = 0; x < size; x += 32) {
                    tx.fillStyle = '#1a3355';
                    tx.fillRect(x+2, y+2, 28, 28);
                    if (Math.random() > 0.5) {
                        tx.fillStyle = '#00aaff';
                        tx.fillRect(x+12, y+12, 8, 8);
                    }
                }
            }
        } else if (type === 5) {
            tx.fillStyle = '#442211';
            tx.fillRect(0, 0, size, size);
            for (let y = 0; y < size; y += 32) {
                for (let x = 0; x < size; x += 32) {
                    tx.fillStyle = '#aa9977';
                    tx.beginPath();
                    tx.arc(x+16, y+14, 10, 0, Math.PI*2);
                    tx.fill();
                    tx.fillStyle = '#220000';
                    tx.fillRect(x+10, y+10, 4, 5);
                    tx.fillRect(x+18, y+10, 4, 5);
                }
            }
        }
        
        textureCache[type] = c;
        return c;
    }
    
    // Спавн врага В ПОЛЕ ЗРЕНИЯ игрока
    function spawnEnemy() {
        if (enemies.length >= MAX_ENEMIES) return;
        
        // Находим точки спавна В ПОЛЕ ЗРЕНИЯ игрока
        const validPoints = spawnPoints.filter(p => {
            const dx = p.x - player.x;
            const dy = p.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            // Не слишком близко
            if (dist < 4) return false;
            
            // Проверяем что точка В ПОЛЕ ЗРЕНИЯ (перед игроком)
            const angleToPoint = Math.atan2(dy, dx);
            let angleDiff = angleToPoint - player.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            
            // Точка должна быть в пределах 60 градусов от направления взгляда
            if (Math.abs(angleDiff) > Math.PI / 3) return false;
            
            // Проверяем что нет других врагов рядом
            for (const e of enemies) {
                if (Math.sqrt((e.x-p.x)**2 + (e.y-p.y)**2) < 2) return false;
            }
            return true;
        });
        
        if (validPoints.length === 0) return;
        const point = validPoints[Math.floor(Math.random() * validPoints.length)];
        
        // Выбор типа врага
        const difficulty = Math.min(player.kills / 20, 1);
        const roll = Math.random();
        let type;
        if (roll < 0.4 - difficulty * 0.2) type = 'imp';
        else if (roll < 0.7 - difficulty * 0.1) type = 'demon';
        else if (roll < 0.9) type = 'soldier';
        else type = 'baron';
        
        const data = ENEMY_TYPES[type];
        const scale = 1 + player.kills * 0.02;
        
        enemies.push({
            x: point.x, y: point.y,
            type: type,
            health: data.health * scale,
            maxHealth: data.health * scale,
            state: 'chase',
            lastAttack: 0,
            stateTime: Date.now()
        });
        
        showMessage('ВРАГ ПОЯВИЛСЯ!');
    }
    
    function spawnItems() {
        const positions = [{x:5,y:5},{x:19,y:5},{x:5,y:15},{x:19,y:15},{x:12,y:5},{x:12,y:15}];
        for (const p of positions) {
            if (!items.some(i => Math.abs(i.x-p.x)<0.5 && Math.abs(i.y-p.y)<0.5)) {
                items.push({ x: p.x, y: p.y, type: Math.random() > 0.5 ? 'health' : 'armor' });
            }
        }
    }
    
    function isWall(x, y) {
        const mx = Math.floor(x), my = Math.floor(y);
        if (mx < 0 || my < 0 || mx >= levelMap[0].length || my >= levelMap.length) return true;
        return levelMap[my][mx] > 0;
    }
    
    function checkLOS(x1, y1, x2, y2) {
        const dx = x2 - x1, dy = y2 - y1;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const steps = Math.ceil(dist * 4);
        for (let i = 1; i < steps; i++) {
            const t = i / steps;
            if (isWall(x1 + dx*t, y1 + dy*t)) return false;
        }
        return true;
    }
    
    function castRay(angle) {
        const cos = Math.cos(angle), sin = Math.sin(angle);
        let mapX = Math.floor(player.x), mapY = Math.floor(player.y);
        const deltaX = Math.abs(1/cos), deltaY = Math.abs(1/sin);
        let stepX, stepY, sideDistX, sideDistY;
        
        if (cos < 0) { stepX = -1; sideDistX = (player.x - mapX) * deltaX; }
        else { stepX = 1; sideDistX = (mapX + 1 - player.x) * deltaX; }
        if (sin < 0) { stepY = -1; sideDistY = (player.y - mapY) * deltaY; }
        else { stepY = 1; sideDistY = (mapY + 1 - player.y) * deltaY; }
        
        let side = 0, dist = 0;
        while (dist < 25) {
            if (sideDistX < sideDistY) {
                sideDistX += deltaX; mapX += stepX; side = 0; dist = sideDistX - deltaX;
            } else {
                sideDistY += deltaY; mapY += stepY; side = 1; dist = sideDistY - deltaY;
            }
            if (mapX < 0 || mapY < 0 || mapX >= levelMap[0].length || mapY >= levelMap.length) break;
            const tile = levelMap[mapY][mapX];
            if (tile > 0) {
                let wallX = side === 0 ? player.y + dist * sin : player.x + dist * cos;
                wallX -= Math.floor(wallX);
                return { distance: dist, type: tile, side, texCoord: wallX };
            }
        }
        return { distance: 25, type: 0, side: 0 };
    }
    
    function render() {
        const w = canvas.width, h = canvas.height - 60;
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, w, canvas.height);
        
        // Небо
        const sky = ctx.createLinearGradient(0, 0, 0, h/2);
        sky.addColorStop(0, '#0a0a1a');
        sky.addColorStop(1, '#1a1a2e');
        ctx.fillStyle = sky;
        ctx.fillRect(0, 0, w, h/2);
        
        // Пол
        const floor = ctx.createLinearGradient(0, h/2, 0, h);
        floor.addColorStop(0, '#2a1a1a');
        floor.addColorStop(1, '#0f0808');
        ctx.fillStyle = floor;
        ctx.fillRect(0, h/2, w, h/2);
        
        // Стены
        const fov = 75 * Math.PI / 180;
        const numRays = Math.min(w, 320);
        const rayStep = w / numRays;
        const zBuffer = [];
        
        for (let i = 0; i < numRays; i++) {
            const rayAngle = player.angle - fov/2 + (i/numRays) * fov;
            const ray = castRay(rayAngle);
            const corrDist = ray.distance * Math.cos(rayAngle - player.angle);
            zBuffer[i] = corrDist;
            
            if (ray.type > 0) {
                const wallH = (h / corrDist) * 0.8;
                const wallTop = (h - wallH) / 2 + player.pitch * 100;
                const tex = generateTexture(ray.type);
                const texX = Math.floor(ray.texCoord * tex.width);
                
                ctx.drawImage(tex, texX, 0, 1, tex.height, i*rayStep, wallTop, rayStep+1, wallH);
                
                const shade = ray.side === 1 ? 0.7 : 1.0;
                const distShade = Math.max(0.2, 1 - corrDist/25);
                ctx.fillStyle = `rgba(0,0,0,${1 - shade * distShade})`;
                ctx.fillRect(i*rayStep, wallTop, rayStep+1, wallH);
            }
        }
        
        // Спрайты
        const sprites = [...enemies, ...items].map(s => {
            const dx = s.x - player.x, dy = s.y - player.y;
            return { ...s, dist: Math.sqrt(dx*dx + dy*dy) };
        }).sort((a, b) => b.dist - a.dist);
        
        for (const sprite of sprites) {
            const dx = sprite.x - player.x, dy = sprite.y - player.y;
            const cosA = Math.cos(player.angle), sinA = Math.sin(player.angle);
            const camX = dx * cosA + dy * sinA;
            const camY = -dx * sinA + dy * cosA;
            
            if (camX <= 0.1) continue;
            
            const screenX = w/2 + (camY / camX) * (w/2) / Math.tan(fov/2);
            const size = sprite.type && ENEMY_TYPES[sprite.type] ? ENEMY_TYPES[sprite.type].size : 0.25;
            const spriteH = (h / camX) * size;
            const spriteW = spriteH;
            const spriteTop = (h - spriteH) / 2 + player.pitch * 100;
            const spriteLeft = screenX - spriteW / 2;
            
            // Проверка Z-buffer
            const startCol = Math.max(0, Math.floor(spriteLeft / rayStep));
            const endCol = Math.min(numRays - 1, Math.floor((spriteLeft + spriteW) / rayStep));
            let visible = false;
            for (let col = startCol; col <= endCol; col++) {
                if (zBuffer[col] > camX) { visible = true; break; }
            }
            if (!visible) continue;
            
            if (ENEMY_TYPES[sprite.type]) {
                // Враг
                const type = ENEMY_TYPES[sprite.type];
                const walkPhase = sprite.state === 'chase' ? Math.sin(Date.now() * 0.01) * 0.3 : 0;
                
                // Тело
                ctx.fillStyle = type.color;
                ctx.fillRect(spriteLeft + spriteW*0.2, spriteTop + spriteH*0.3, spriteW*0.6, spriteH*0.5);
                
                // Голова
                ctx.beginPath();
                ctx.arc(spriteLeft + spriteW/2, spriteTop + spriteH*0.2, spriteW*0.2, 0, Math.PI*2);
                ctx.fill();
                
                // Глаза
                ctx.fillStyle = '#ff0000';
                ctx.shadowColor = '#ff0000';
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(spriteLeft + spriteW*0.4, spriteTop + spriteH*0.18, spriteW*0.05, 0, Math.PI*2);
                ctx.arc(spriteLeft + spriteW*0.6, spriteTop + spriteH*0.18, spriteW*0.05, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Ноги
                ctx.fillStyle = type.color;
                const legOff = walkPhase * spriteW * 0.1;
                ctx.fillRect(spriteLeft + spriteW*0.25 - legOff, spriteTop + spriteH*0.8, spriteW*0.2, spriteH*0.2);
                ctx.fillRect(spriteLeft + spriteW*0.55 + legOff, spriteTop + spriteH*0.8, spriteW*0.2, spriteH*0.2);
                
                // Полоска здоровья
                if (sprite.health < sprite.maxHealth) {
                    const hp = sprite.health / sprite.maxHealth;
                    ctx.fillStyle = '#000';
                    ctx.fillRect(spriteLeft, spriteTop - 10, spriteW, 6);
                    ctx.fillStyle = hp > 0.5 ? '#0f0' : hp > 0.25 ? '#ff0' : '#f00';
                    ctx.fillRect(spriteLeft+1, spriteTop - 9, (spriteW-2) * hp, 4);
                }
            } else {
                // Предмет
                const bob = Math.sin(Date.now() * 0.005) * spriteH * 0.1;
                ctx.fillStyle = sprite.type === 'health' ? '#ff4444' : '#4444ff';
                ctx.shadowColor = sprite.type === 'health' ? '#ff0000' : '#0000ff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.arc(spriteLeft + spriteW/2, spriteTop + spriteH/2 + bob, spriteW*0.4, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.font = `bold ${spriteW*0.4}px Arial`;
                ctx.textAlign = 'center';
                ctx.fillText(sprite.type === 'health' ? '+' : 'Б', spriteLeft + spriteW/2, spriteTop + spriteH/2 + bob + spriteW*0.15);
                ctx.shadowBlur = 0;
            }
        }
        
        // Снаряды
        for (const proj of projectiles) {
            const dx = proj.x - player.x, dy = proj.y - player.y;
            const cosA = Math.cos(player.angle), sinA = Math.sin(player.angle);
            const camX = dx * cosA + dy * sinA;
            const camY = -dx * sinA + dy * cosA;
            if (camX <= 0.1) continue;
            
            const screenX = w/2 + (camY / camX) * (w/2) / Math.tan(fov/2);
            const screenY = h/2 + player.pitch * 100;
            const size = (h / camX) * 0.1;
            
            ctx.fillStyle = proj.isEnemy ? '#ff6600' : '#00ffff';
            ctx.shadowColor = proj.isEnemy ? '#ff6600' : '#00ffff';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(screenX, screenY, size, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
        }
        
        // Частицы
        for (const p of particles) {
            const dx = p.x - player.x, dy = p.y - player.y;
            const cosA = Math.cos(player.angle), sinA = Math.sin(player.angle);
            const camX = dx * cosA + dy * sinA;
            const camY = -dx * sinA + dy * cosA;
            if (camX <= 0.1) continue;
            
            const screenX = w/2 + (camY / camX) * (w/2) / Math.tan(fov/2);
            const screenY = h/2 + player.pitch * 100 - (p.z - 0.5) * (h / camX);
            const size = (h / camX) * 0.03 * p.size;
            
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(screenX - size/2, screenY - size/2, size, size);
            ctx.globalAlpha = 1;
        }
        
        // Оружие
        renderWeapon(w, h);
        
        // Миникарта
        renderMinimap();
    }
    
    function renderWeapon(w, h) {
        const weapon = player.weapons[player.currentWeapon];
        const ww = w * 0.25, wh = h * 0.3;
        const bobX = Math.sin(player.bobPhase) * 6;
        const bobY = Math.abs(Math.sin(player.bobPhase * 2)) * 4;
        const baseX = w/2 - ww/2 + bobX;
        const baseY = h - wh + 40 + bobY;
        const recoil = Math.max(0, 50 - (Date.now() - player.lastFireTime)) / 50 * 15;
        
        ctx.save();
        ctx.translate(baseX + ww/2, baseY + wh);
        ctx.rotate(-recoil * 0.02);
        ctx.translate(-(baseX + ww/2), -(baseY + wh));
        
        if (weapon.isKnife) {
            // Нож
            // Рукоять
            ctx.fillStyle = '#4a3728';
            ctx.fillRect(baseX + ww*0.4, baseY + wh*0.5, ww*0.2, wh*0.5);
            
            // Гарда
            ctx.fillStyle = '#666';
            ctx.fillRect(baseX + ww*0.3, baseY + wh*0.45, ww*0.4, wh*0.08);
            
            // Лезвие
            ctx.fillStyle = '#ccc';
            ctx.beginPath();
            ctx.moveTo(baseX + ww*0.35, baseY + wh*0.45 - recoil*2);
            ctx.lineTo(baseX + ww*0.65, baseY + wh*0.45 - recoil*2);
            ctx.lineTo(baseX + ww*0.5, baseY - recoil*3);
            ctx.closePath();
            ctx.fill();
            
            // Блик на лезвии
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.moveTo(baseX + ww*0.48, baseY + wh*0.2 - recoil*2);
            ctx.lineTo(baseX + ww*0.52, baseY + wh*0.2 - recoil*2);
            ctx.lineTo(baseX + ww*0.5, baseY + wh*0.05 - recoil*3);
            ctx.closePath();
            ctx.fill();
            
            // Кровь на лезвии при недавней атаке
            if (Date.now() - player.lastFireTime < 500) {
                ctx.fillStyle = '#aa0000';
                ctx.beginPath();
                ctx.arc(baseX + ww*0.45, baseY + wh*0.2, ww*0.05, 0, Math.PI*2);
                ctx.arc(baseX + ww*0.55, baseY + wh*0.3, ww*0.04, 0, Math.PI*2);
                ctx.fill();
            }
        } else {
            // Плазменное оружие
            // Корпус
            ctx.fillStyle = '#2244aa';
            ctx.fillRect(baseX + ww*0.25, baseY + wh*0.3, ww*0.5, wh*0.5);
            
            // Ствол
            ctx.fillStyle = '#3355cc';
            ctx.fillRect(baseX + ww*0.35, baseY - recoil, ww*0.3, wh*0.4);
            
            // Энергетическое ядро
            const pulse = Math.sin(Date.now() * 0.01) * 0.3 + 0.7;
            ctx.fillStyle = `rgba(0, 255, 255, ${pulse})`;
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(baseX + ww*0.5, baseY + wh*0.5, ww*0.12, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Вспышка при выстреле
            if (Date.now() - player.lastFireTime < 80) {
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 40;
                ctx.beginPath();
                ctx.arc(baseX + ww*0.5, baseY - 20 - recoil, 25, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        ctx.restore();
    }
    
    function renderMinimap() {
        minimapCtx.fillStyle = 'rgba(0,0,0,0.8)';
        minimapCtx.fillRect(0, 0, 100, 100);
        
        const scale = 100 / 25;
        for (let y = 0; y < levelMap.length; y++) {
            for (let x = 0; x < levelMap[0].length; x++) {
                if (levelMap[y][x] > 0) {
                    minimapCtx.fillStyle = '#444';
                    minimapCtx.fillRect(x*scale, y*scale, scale, scale);
                }
            }
        }
        
        for (const e of enemies) {
            minimapCtx.fillStyle = '#f00';
            minimapCtx.fillRect(e.x*scale-2, e.y*scale-2, 4, 4);
        }
        
        minimapCtx.fillStyle = '#0f0';
        minimapCtx.beginPath();
        minimapCtx.arc(player.x*scale, player.y*scale, 3, 0, Math.PI*2);
        minimapCtx.fill();
        
        minimapCtx.strokeStyle = '#0f0';
        minimapCtx.beginPath();
        minimapCtx.moveTo(player.x*scale, player.y*scale);
        minimapCtx.lineTo(player.x*scale + Math.cos(player.angle)*8, player.y*scale + Math.sin(player.angle)*8);
        minimapCtx.stroke();
    }
    
    function update(dt) {
        const now = Date.now();
        
        // Спавн врагов
        if (now - lastSpawnTime > SPAWN_INTERVAL) {
            spawnEnemy();
            lastSpawnTime = now;
        }
        
        // Респавн предметов
        if (now % 15000 < 50) spawnItems();
        
        // Обновление врагов
        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            const type = ENEMY_TYPES[e.type];
            const dx = player.x - e.x, dy = player.y - e.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const hasLOS = checkLOS(e.x, e.y, player.x, player.y);
            
            if (e.state === 'chase' && hasLOS) {
                const minDist = type.ranged ? 3 : 1;
                if (dist > minDist) {
                    const speed = type.speed * dt;
                    const mx = (dx / dist) * speed;
                    const my = (dy / dist) * speed;
                    if (!isWall(e.x + mx, e.y)) e.x += mx;
                    if (!isWall(e.x, e.y + my)) e.y += my;
                }
                
                if (dist < type.attackRange && now - e.lastAttack > type.attackCooldown) {
                    e.state = 'attack';
                    e.stateTime = now;
                }
            }
            
            if (e.state === 'attack') {
                if (now - e.stateTime > 200 && !e.attacked) {
                    e.attacked = true;
                    e.lastAttack = now;
                    
                    if (type.ranged && dist > 1.5) {
                        const angle = Math.atan2(dy, dx);
                        projectiles.push({
                            x: e.x, y: e.y,
                            vx: Math.cos(angle) * type.projectileSpeed,
                            vy: Math.sin(angle) * type.projectileSpeed,
                            damage: type.damage,
                            isEnemy: true
                        });
                    } else if (dist < 1.5) {
                        damagePlayer(type.damage);
                    }
                }
                
                if (now - e.stateTime > 400) {
                    e.state = 'chase';
                    e.attacked = false;
                }
            }
            
            // Смерть
            if (e.health <= 0) {
                for (let j = 0; j < 20; j++) {
                    particles.push({
                        x: e.x + (Math.random()-0.5)*0.5,
                        y: e.y + (Math.random()-0.5)*0.5,
                        z: Math.random(),
                        vx: (Math.random()-0.5)*4,
                        vy: (Math.random()-0.5)*4,
                        vz: Math.random()*3,
                        life: 1,
                        color: '#880000',
                        size: 0.5 + Math.random()*0.5
                    });
                }
                player.kills++;
                
                // Лечение за убийство
                const healAmount = 10;
                player.health = Math.min(player.maxHealth, player.health + healAmount);
                showHealEffect();
                
                enemies.splice(i, 1);
                showMessage(`УБИЙСТВО! +${healAmount} HP (${player.kills} убийств)`);
            }
        }
        
        // Обновление снарядов
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            
            if (isWall(p.x, p.y)) {
                projectiles.splice(i, 1);
                continue;
            }
            
            if (p.isEnemy) {
                const dx = player.x - p.x, dy = player.y - p.y;
                if (Math.sqrt(dx*dx + dy*dy) < 0.4) {
                    damagePlayer(p.damage);
                    projectiles.splice(i, 1);
                }
            } else {
                // Снаряд игрока
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    const dx = e.x - p.x, dy = e.y - p.y;
                    if (Math.sqrt(dx*dx + dy*dy) < 0.5) {
                        e.health -= p.damage;
                        // Частицы при попадании
                        for (let k = 0; k < 5; k++) {
                            particles.push({
                                x: e.x + (Math.random()-0.5)*0.3,
                                y: e.y + (Math.random()-0.5)*0.3,
                                z: 0.5,
                                vx: (Math.random()-0.5)*3,
                                vy: (Math.random()-0.5)*3,
                                vz: Math.random()*2,
                                life: 0.5,
                                color: '#00ffff',
                                size: 0.3
                            });
                        }
                        projectiles.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        // Обновление частиц
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.z += (p.vz || 0) * dt;
            p.vz = (p.vz || 0) - 8 * dt;
            p.life -= dt * 1.5;
            if (p.life <= 0 || p.z < 0) particles.splice(i, 1);
        }
        
        // Подбор предметов
        for (let i = items.length - 1; i >= 0; i--) {
            const item = items[i];
            const dx = player.x - item.x, dy = player.y - item.y;
            if (Math.sqrt(dx*dx + dy*dy) < 0.6) {
                if (item.type === 'health' && player.health < player.maxHealth) {
                    player.health = Math.min(player.maxHealth, player.health + 25);
                    showMessage('ЗДОРОВЬЕ +25');
                    showHealEffect();
                    items.splice(i, 1);
                } else if (item.type === 'armor' && player.armor < player.maxArmor) {
                    player.armor = Math.min(player.maxArmor, player.armor + 50);
                    showMessage('БРОНЯ +50');
                    items.splice(i, 1);
                }
            }
        }
        
        updateHUD();
    }
    
    function showHealEffect() {
        const overlay = document.getElementById('heal-overlay');
        overlay.style.opacity = 0.5;
        setTimeout(() => overlay.style.opacity = 0, 200);
    }
    
    function damagePlayer(amount) {
        if (player.armor > 0) {
            const absorb = Math.min(player.armor, amount * 0.5);
            player.armor -= absorb;
            amount -= absorb;
        }
        player.health -= amount;
        
        document.getElementById('damage-overlay').style.opacity = 0.6;
        setTimeout(() => document.getElementById('damage-overlay').style.opacity = 0, 150);
        
        if (player.health <= 0) {
            player.health = 0;
            gameOver();
        }
    }
    
    function fire() {
        const weapon = player.weapons[player.currentWeapon];
        if (Date.now() - player.lastFireTime < weapon.fireRate) return;
        
        player.lastFireTime = Date.now();
        
        if (weapon.isKnife) {
            // Нож - убивает одним ударом вблизи
            let hitEnemy = null;
            let closestDist = weapon.range;
            
            for (const e of enemies) {
                const dx = e.x - player.x, dy = e.y - player.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                // Проверяем что враг перед нами
                const eAngle = Math.atan2(dy, dx);
                let diff = eAngle - player.angle;
                while (diff > Math.PI) diff -= 2*Math.PI;
                while (diff < -Math.PI) diff += 2*Math.PI;
                
                if (dist < closestDist && Math.abs(diff) < Math.PI/3) {
                    closestDist = dist;
                    hitEnemy = e;
                }
            }
            
            if (hitEnemy) {
                hitEnemy.health = 0; // Мгновенное убийство
                
                // Частицы крови
                for (let j = 0; j < 15; j++) {
                    particles.push({
                        x: hitEnemy.x + (Math.random()-0.5)*0.3,
                        y: hitEnemy.y + (Math.random()-0.5)*0.3,
                        z: 0.5,
                        vx: (Math.random()-0.5)*5,
                        vy: (Math.random()-0.5)*5,
                        vz: Math.random()*3,
                        life: 1,
                        color: '#aa0000',
                        size: 0.4
                    });
                }
            }
        } else {
            // Плазменное оружие - стреляет снарядами
            const spread = (Math.random() - 0.5) * weapon.spread;
            const angle = player.angle + spread;
            
            projectiles.push({
                x: player.x + Math.cos(angle) * 0.5,
                y: player.y + Math.sin(angle) * 0.5,
                vx: Math.cos(angle) * weapon.projectileSpeed,
                vy: Math.sin(angle) * weapon.projectileSpeed,
                damage: weapon.damage,
                isEnemy: false
            });
        }
    }
    
    function switchWeapon() {
        player.currentWeapon = (player.currentWeapon + 1) % player.weapons.length;
        showMessage(player.weapons[player.currentWeapon].name);
    }
    
    function showMessage(text) {
        const msg = document.getElementById('message');
        msg.textContent = text;
        msg.style.display = 'block';
        clearTimeout(msg.timeout);
        msg.timeout = setTimeout(() => msg.style.display = 'none', 2000);
    }
    
    function updateHUD() {
        document.querySelector('#health .hud-value').textContent = Math.floor(player.health);
        document.querySelector('#armor .hud-value').textContent = Math.floor(player.armor);
        document.querySelector('#kills .hud-value').textContent = player.kills;
        document.querySelector('#weapon .hud-value').textContent = player.weapons[player.currentWeapon].name;
    }
    
    function gameOver() {
        gameRunning = false;
        document.getElementById('final-kills').textContent = player.kills;
        document.getElementById('gameover').style.display = 'flex';
    }
    
    function startGame() {
        player.x = 12; player.y = 12;
        player.angle = 0; player.pitch = 0;
        player.health = 100; player.armor = 0;
        player.currentWeapon = 0;
        player.kills = 0;
        
        enemies = [];
        items = [];
        projectiles = [];
        particles = [];
        lastSpawnTime = Date.now();
        
        // Начальные враги (мало)
        for (let i = 0; i < 3; i++) spawnEnemy();
        spawnItems();
        
        document.getElementById('menu').classList.add('hidden');
        document.getElementById('gameover').style.display = 'none';
        document.getElementById('hud').classList.remove('hidden');
        document.getElementById('joystick-container').classList.remove('hidden');
        document.getElementById('look-area').classList.remove('hidden');
        document.getElementById('fire-btn').classList.remove('hidden');
        document.getElementById('weapon-btn').classList.remove('hidden');
        document.getElementById('crosshair').classList.remove('hidden');
        document.getElementById('level-info').classList.remove('hidden');
        document.getElementById('minimap').classList.remove('hidden');
        document.getElementById('fullscreen-btn').classList.remove('hidden');
        
        gameRunning = true;
    }
    
    // Управление
    let moveX = 0, moveY = 0, isFiring = false;
    const keys = {};
    const joystick = { active: false, startX: 0, startY: 0, touchId: null };
    const look = { active: false, lastX: 0, lastY: 0, touchId: null };
    
    function setupControls() {
        const jc = document.getElementById('joystick-container');
        const js = document.getElementById('joystick-stick');
        const la = document.getElementById('look-area');
        const fb = document.getElementById('fire-btn');
        const wb = document.getElementById('weapon-btn');
        
        jc.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            joystick.active = true;
            joystick.touchId = t.identifier;
            joystick.startX = t.clientX;
            joystick.startY = t.clientY;
        }, {passive:false});
        
        jc.addEventListener('touchmove', e => {
            e.preventDefault();
            for (const t of e.changedTouches) {
                if (t.identifier === joystick.touchId) {
                    const dx = t.clientX - joystick.startX;
                    const dy = t.clientY - joystick.startY;
                    const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
                    const angle = Math.atan2(dy, dx);
                    const sx = Math.cos(angle) * dist;
                    const sy = Math.sin(angle) * dist;
                    js.style.transform = `translate(calc(-50% + ${sx}px), calc(-50% + ${sy}px))`;
                    moveX = sx / 40;
                    moveY = sy / 40;
                }
            }
        }, {passive:false});
        
        jc.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier === joystick.touchId) {
                    joystick.active = false;
                    js.style.transform = 'translate(-50%, -50%)';
                    moveX = moveY = 0;
                }
            }
        });
        
        la.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.changedTouches[0];
            look.active = true;
            look.touchId = t.identifier;
            look.lastX = t.clientX;
            look.lastY = t.clientY;
        }, {passive:false});
        
        la.addEventListener('touchmove', e => {
            e.preventDefault();
            for (const t of e.changedTouches) {
                if (t.identifier === look.touchId) {
                    player.angle += (t.clientX - look.lastX) * 0.004;
                    player.pitch = Math.max(-0.5, Math.min(0.5, player.pitch - (t.clientY - look.lastY) * 0.002));
                    look.lastX = t.clientX;
                    look.lastY = t.clientY;
                }
            }
        }, {passive:false});
        
        la.addEventListener('touchend', e => {
            for (const t of e.changedTouches) {
                if (t.identifier === look.touchId) look.active = false;
            }
        });
        
        fb.addEventListener('touchstart', e => { e.preventDefault(); isFiring = true; fire(); }, {passive:false});
        fb.addEventListener('touchend', e => { e.preventDefault(); isFiring = false; }, {passive:false});
        wb.addEventListener('touchstart', e => { e.preventDefault(); switchWeapon(); }, {passive:false});
        
        document.getElementById('fullscreen-btn').addEventListener('click', toggleFullscreen);
        document.getElementById('fullscreen-menu-btn').addEventListener('click', toggleFullscreen);
        document.getElementById('start-btn').addEventListener('click', startGame);
        document.getElementById('restart-btn').addEventListener('click', startGame);
        document.getElementById('menu-btn').addEventListener('click', () => {
            document.getElementById('gameover').style.display = 'none';
            document.getElementById('menu').classList.remove('hidden');
        });
        
        document.addEventListener('keydown', e => {
            keys[e.key.toLowerCase()] = true;
            if (e.key === ' ' && gameRunning) { e.preventDefault(); isFiring = true; fire(); }
            if (e.key === 'f') toggleFullscreen();
            if (e.key === 'q' || e.key === 'й') switchWeapon();
        });
        
        document.addEventListener('keyup', e => {
            keys[e.key.toLowerCase()] = false;
            if (e.key === ' ') isFiring = false;
        });
        
        canvas.addEventListener('click', () => {
            if (gameRunning) canvas.requestPointerLock?.();
        });
        
        document.addEventListener('mousemove', e => {
            if (document.pointerLockElement === canvas) {
                player.angle += e.movementX * 0.003;
                player.pitch = Math.max(-0.5, Math.min(0.5, player.pitch - e.movementY * 0.002));
            }
        });
        
        document.addEventListener('mousedown', e => {
            if (document.pointerLockElement === canvas && e.button === 0) {
                isFiring = true; fire();
            }
        });
        
        document.addEventListener('mouseup', e => {
            if (e.button === 0) isFiring = false;
        });
    }
    
    function updateMovement(dt) {
        if (!gameRunning) return;
        
        let kx = 0, ky = 0;
        if (keys['w'] || keys['ц'] || keys['arrowup']) ky = -1;
        if (keys['s'] || keys['ы'] || keys['arrowdown']) ky = 1;
        if (keys['a'] || keys['ф']) kx = -1;
        if (keys['d'] || keys['в']) kx = 1;
        if (keys['arrowleft']) player.angle -= 2 * dt;
        if (keys['arrowright']) player.angle += 2 * dt;
        
        const ix = kx || moveX;
        const iy = ky || moveY;
        
        if (ix !== 0 || iy !== 0) player.bobPhase += dt * 10;
        
        const speed = 6 * dt;
        const fx = Math.cos(player.angle) * (-iy) * speed;
        const fy = Math.sin(player.angle) * (-iy) * speed;
        const sx = Math.cos(player.angle + Math.PI/2) * ix * speed;
        const sy = Math.sin(player.angle + Math.PI/2) * ix * speed;
        
        const nx = player.x + fx + sx;
        const ny = player.y + fy + sy;
        const m = 0.25;
        
        if (!isWall(nx+m, player.y) && !isWall(nx-m, player.y)) player.x = nx;
        if (!isWall(player.x, ny+m) && !isWall(player.x, ny-m)) player.y = ny;
        
        // Автоматическая стрельба для плазмы
        if (isFiring && player.weapons[player.currentWeapon].auto) fire();
    }
    
    function gameLoop(timestamp) {
        const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
        lastTime = timestamp;
        
        if (gameRunning) {
            updateMovement(dt);
            update(dt);
            render();
        }
        
        requestAnimationFrame(gameLoop);
    }
    
    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        setupControls();
        checkOrientation();
        [1,2,3,5].forEach(t => generateTexture(t));
        requestAnimationFrame(gameLoop);
    }
    
    init();
    </script>
</body>
</html>
